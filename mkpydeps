#!/usr/bin/env python

""" mkpydeps 0.2

Invoked like "mkpydeps foo" for some package foo **which is presently
installed in sys.path**, determines which packages foo and its dependents
depend on, downloads them from pypi and computes their checksums, and
spits out Homebrew resource stanzas.

`pip install tl.eggdeps jinja2 networkx` first, please.
"""

import os, sys, json, urllib2
from hashlib import sha1
import tl.eggdeps.graph
import pip
from pip.compat import stdlib_pkgs
import networkx as nx
from jinja2 import Template

TEMPLATE="""
class {{ package.name|capitalize }} < Formula
  homepage "{{ package.homepage }}"
  url "{{ package.url }}"
  sha1 "{{ package.checksum }}"

  ... add dependencies
  {% if has_resources %}{% for resource in resources %}
  resource "{{ resource.name }}" do
    url "{{ resource.url }}"
    sha1 "{{ resource.checksum }}"
  end
  {% endfor %}{% endif %}
  def install
    {% if has_resources %}ENV.prepend_create_path "PYTHONPATH", libexec/"vendor/lib/python{{ py_version }}/site-packages"
    %w[{{ resources|map(attribute='name')|join(' ') }}].each do |r|
      resource(r).stage do
        system "python", *Language::Python.setup_install_args(libexec/"vendor")
      end
    end

{% endif %}
    ... add custom changes

    ENV.prepend_create_path "PYTHONPATH", libexec/"lib/python{{ py_version }}/site-packages"
    system "python", *Language::Python.setup_install_args(libexec)

    ... add custom changes

    bin.install Dir[libexec/"bin/*"]
    bin.env_script_all_files(libexec/"bin", :PYTHONPATH => ENV["PYTHONPATH"])
  end
end
"""

pkg = sys.argv[1]

egg_graph = tl.eggdeps.graph.Graph()
egg_graph.from_specifications(pkg)

# create graph
G = nx.DiGraph()
stdlib_pkgs = set(stdlib_pkgs)
keys = set(egg_graph.keys()) - stdlib_pkgs
G.add_nodes_from(keys)
G.add_edges_from([(k, v) for k in keys for v in
    set(egg_graph[k].keys()) - stdlib_pkgs])

# add version attribute
installed_packages = pip.get_installed_distributions()
versions = dict((el.key,el.version) for el in installed_packages)
for n in G.nodes():
    G.node[n]['version'] = versions[n]

# add more node info
for n in G.nodes():
    f = urllib2.urlopen("http://pypi.python.org/pypi/{}/{}/json".format(n,
        G.node[n]['version']))
    j = json.load(f)
    f.close()
    G.node[n]['name'] = j['info']['name']
    G.node[n]['homepage'] = j['info'].get('home_page', 'PUT THE PACKAGE URL')
    for i in j['urls']:
        if i['packagetype'] == 'sdist':
            G.node[n]['url'] = i['url']
            f = urllib2.urlopen(G.node[n]['url'])
            G.node[n]['checksum'] = sha1(f.read()).hexdigest()

# get the dependency resolution order
deps = nx.algorithms.dag.topological_sort(G)
deps.reverse()

resources = map( lambda n : G.node[n], filter(lambda n :
    G.node[n]['name'].lower() != pkg.lower(), G.nodes()))
root = G.node[pkg]

template = Template(TEMPLATE)
has_resources = len(resources) != 0
print template.render(package=root, has_resources=has_resources, resources=resources, py_version="2.7")
